# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12cF4chj_XPLXh_KxMvKeGy4p5I9oF3zy
"""

"EX1-QST2"
import numpy as np

A = [[5/6, 1/12, 1/12],
     [1/4, 1/2, 1/4],
     [1/4, 0, 3/4]]

eigenvalues, eigenvectors = np.linalg.eig(np.transpose(A))

# Search for the eigenvector corresponding to eigenvalue 1
for i in range(len(eigenvalues)):
    if abs(eigenvalues[i] - 1.0) < 1e-6:
        invariant_probability = eigenvectors[:,i]
        print(invariant_probability)

"EX1-QST3-4"
import numpy as np

def matrix_power(P, n):
    mu_0 = np.array([0,0,0,1,0,0,0,0,0])
    result = mu_0
    for i in range(n):
        result = np.dot(result, P)
    return result

P = np.array([[1,0,0,0,0,0,0,0,0],[0.6,0,0.4,0,0,0,0,0,0],[0,0.6,0,0.4,0,0,0,0,0],[0,0,0.6,0,0.4,0,0,0,0],[0,0,0,0.6,0,0.4,0,0,0],[0,0,0,0,0.6,0,0.4,0,0],[0,0,0,0,0,0.6,0,0.4,0],[0,0,0,0,0,0,0.6,0,0.4],[0,0,0,0,0,0,0,0,1]]) 
n = 3
m=10

l=100
print("pour n=3",matrix_power(P, n))
print("pour n=10",matrix_power(P, m))

print("pour n=100",matrix_power(P, l))

"EX1-QST5"
def power_n(A,n):
  return np.linalg.matrix_power(A, n)



print("si n=5 : ",power_n(A,5))
print("si n=10 : ",power_n(A,10))
print("si n=50 : ",power_n(A,50))
print("si n=100 : ",power_n(A,100))

"EX1-QST6"
def adam(X):
    U= np.random.rand(1)[0]
    if (X==1):
      return 1*(U<5/6)+2*(5/6< U < 11/12)+3*(11/12<U)
      
    if (X==2):
      return 1*(U < 1/4)+2*(1/4 <U < 3/4)+3*(3/4<U)
    if (X==3):
      return 1*(U < 1/4)+3*(1/4 < U)

"EX2-QST3"
import numpy as np

# Proba de ganer 1 euro
gain = 0.4

# Proba de perde 1 euro
perte = 0.6

# Nombre de valeurs prises 
nmbr_ttl = 9


A = np.zeros((nmbr_ttl, nmbr_ttl))

for i in range(9):
    for j in range(9):
        if j == i - 1:
            A[i, j] = perte
        elif j == i + 1:
            # ganger un euro
            A[i, j] = gain
        elif j == i:
        # nulle sue la diagonale à l'exeption des 2 élements absorbants
            A[i, j] = 1 - perte - gain
        A[0, 0]=1
        A[8, 8]=1
        A[0, 1]=0
        A[8, 7]=0


print("A=",A)

"EX2-QST4"
def Simulation_uniforme(X):
    U= np.random.rand(1)[0]
    if (X==0):
            return 0
    if (X==1):
        if U < 6/10:
            return 0
        else :
            return 2
    if (X==2):
        if U < 6/10:
            return 1
        else :
            return 3
    if (X==3):
        if U < 6/10:
            return 2
        else :
            return 4
    if (X==4):
        if U < 6/10:
            return 3
        else :
            return 5
    if (X==5):
        if U < 6/10:
            return 4
        else :
            return 6
    if (X==6):
        if U < 6/10:
            return 5
        else :
            return 7
    if (X==7):
        if U < 6/10:
            return 6
        else :
            return 8
    if (X==8):
        return 8